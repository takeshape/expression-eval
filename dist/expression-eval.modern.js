import n from"jsep";export{default as parse}from"jsep";const r={"||":1,"&&":2,"|":3,"^":4,"&":5,"==":6,"!=":6,"===":6,"!==":6,"<":7,">":7,"<=":7,">=":7,"<<":8,">>":8,">>>":8,"+":9,"-":9,"*":10,"/":10,"%":10},t={"||":function(n,r){return n||r},"&&":function(n,r){return n&&r},"|":function(n,r){return n|r},"^":function(n,r){return n^r},"&":function(n,r){return n&r},"==":function(n,r){return n==r},"!=":function(n,r){return n!=r},"===":function(n,r){return n===r},"!==":function(n,r){return n!==r},"<":function(n,r){return n<r},">":function(n,r){return n>r},"<=":function(n,r){return n<=r},">=":function(n,r){return n>=r},"<<":function(n,r){return n<<r},">>":function(n,r){return n>>r},">>>":function(n,r){return n>>>r},"+":function(n,r){return n+r},"-":function(n,r){return n-r},"*":function(n,r){return n*r},"/":function(n,r){return n/r},"%":function(n,r){return n%r}},e={"-":function(n){return-n},"+":function(n){return+n},"~":function(n){return~n},"!":function(n){return!n}};function i(n,r,i={}){function a(n){return n.map(function(n){return o(n)})}function u(n){const r=o(n.object);if(n.computed)return[r,r[o(n.property)]];{const t=n.property.name;return[r,i.implicitOptionalChaining&&null==r?void 0:r[t]]}}function o(n){const i=n;switch(i.type){case"ArrayExpression":return a(i.elements);case"BinaryExpression":return t[i.operator](o(i.left),o(i.right));case"CallExpression":let n,c,s;if("MemberExpression"===i.callee.type?(s=u(i.callee),n=s[0],c=s[1]):c=o(i.callee),"function"!=typeof c)return;return c.apply(n,a(i.arguments));case"ConditionalExpression":return o(i.test)?o(i.consequent):o(i.alternate);case"Identifier":return r[i.name];case"Literal":return i.value;case"LogicalExpression":return"||"===i.operator?o(i.left)||o(i.right):"&&"===i.operator?o(i.left)&&o(i.right):t[i.operator](o(i.left),o(i.right));case"MemberExpression":return u(i)[1];case"ThisExpression":return r;case"UnaryExpression":return e[i.operator](o(i.argument));default:return}}return o(n)}async function a(n,r,i={}){async function a(n){return await Promise.all(n.map(n=>o(n)))}async function u(n){const r=await o(n.object);if(n.computed)return[r,r[await o(n.property)]];{const t=n.property.name;return[r,i.implicitOptionalChaining&&null==r?void 0:r[t]]}}async function o(n){const i=n;switch(i.type){case"ArrayExpression":return await a(i.elements);case"BinaryExpression":{const[n,r]=await Promise.all([o(i.left),o(i.right)]);return t[i.operator](n,r)}case"CallExpression":{let n,r,t;if("MemberExpression"===i.callee.type?(t=await u(i.callee),n=t[0],r=t[1]):r=await o(i.callee),"function"!=typeof r)return;return await r.apply(n,await a(i.arguments))}case"ConditionalExpression":return await o(i.test)?await o(i.consequent):await o(i.alternate);case"Identifier":return r[i.name];case"Literal":return i.value;case"LogicalExpression":{if("||"===i.operator)return await o(i.left)||await o(i.right);if("&&"===i.operator)return await o(i.left)&&await o(i.right);const[n,r]=await Promise.all([o(i.left),o(i.right)]);return t[i.operator](n,r)}case"MemberExpression":return(await u(i))[1];case"ThisExpression":return r;case"UnaryExpression":return e[i.operator](await o(i.argument));default:return}}return o(n)}function u(r){return i.bind(null,n(r))}function o(r){return a.bind(null,n(r))}function c(r,t){n.addUnaryOp(r),e[r]=t}function s(e,i,a){a?(n.addBinaryOp(e,i),t[e]=a):(n.addBinaryOp(e,r[e]||1),t[e]=i)}export{s as addBinaryOp,c as addUnaryOp,u as compile,o as compileAsync,i as eval,a as evalAsync};
//# sourceMappingURL=expression-eval.modern.js.map

{"version":3,"file":"expression-eval.umd.js","sources":["../index.ts"],"sourcesContent":["import jsep from 'jsep';\n\n/**\n * Evaluation code from JSEP project, under MIT License.\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\n */\n\n// Default operator precedence from https://github.com/EricSmekens/jsep/blob/master/src/jsep.js#L55\nconst DEFAULT_PRECEDENCE = {\n  '||': 1,\n  '&&': 2,\n  '|': 3,\n  '^': 4,\n  '&': 5,\n  '==': 6,\n  '!=': 6,\n  '===': 6,\n  '!==': 6,\n  '<': 7,\n  '>': 7,\n  '<=': 7,\n  '>=': 7,\n  '<<': 8,\n  '>>': 8,\n  '>>>': 8,\n  '+': 9,\n  '-': 9,\n  '*': 10,\n  '/': 10,\n  '%': 10\n};\n\nconst binops = {\n  '||': function (a, b) { return a || b; },\n  '&&': function (a, b) { return a && b; },\n  '|': function (a, b) { return a | b; },\n  '^': function (a, b) { return a ^ b; },\n  '&': function (a, b) { return a & b; },\n  '==': function (a, b) { return a == b; }, // jshint ignore:line\n  '!=': function (a, b) { return a != b; }, // jshint ignore:line\n  '===': function (a, b) { return a === b; },\n  '!==': function (a, b) { return a !== b; },\n  '<': function (a, b) { return a < b; },\n  '>': function (a, b) { return a > b; },\n  '<=': function (a, b) { return a <= b; },\n  '>=': function (a, b) { return a >= b; },\n  '<<': function (a, b) { return a << b; },\n  '>>': function (a, b) { return a >> b; },\n  '>>>': function (a, b) { return a >>> b; },\n  '+': function (a, b) { return a + b; },\n  '-': function (a, b) { return a - b; },\n  '*': function (a, b) { return a * b; },\n  '/': function (a, b) { return a / b; },\n  '%': function (a, b) { return a % b; }\n};\n\nconst unops = {\n  '-': function (a) { return -a; },\n  '+': function (a) { return +a; },\n  '~': function (a) { return ~a; },\n  '!': function (a) { return !a; },\n};\n\ndeclare type operand = number | string;\ndeclare type unaryCallback = (a: operand) => operand;\ndeclare type binaryCallback = (a: operand, b: operand) => operand;\n\ntype AnyExpression = jsep.ArrayExpression\n  | jsep.BinaryExpression\n  | jsep.MemberExpression\n  | jsep.CallExpression\n  | jsep.ConditionalExpression\n  | jsep.Identifier\n  | jsep.Literal\n  | jsep.LogicalExpression\n  | jsep.ThisExpression\n  | jsep.UnaryExpression;\n\ndeclare interface EvaluateOptions {\n  implicitOptionalChaining?: boolean;\n}\n\nfunction evaluate(_node: jsep.Expression, context: object, options: EvaluateOptions = {}) {\n\n  function evaluateArray(list) {\n    return list.map(function (v) { return evaluateNode(v); });\n  }\n\n  function evaluateMember(node: jsep.MemberExpression) {\n    const object = evaluateNode(node.object);\n    if (node.computed) {\n      return [object, object[evaluateNode(node.property)]];\n    } else {\n      const name = (node.property as jsep.Identifier).name;\n      return [object, options.implicitOptionalChaining ? object?.[name] : object[name]]\n    }\n  }\n\n  function evaluateNode(_jsepNode: jsep.Expression) {\n\n    const node = _jsepNode as AnyExpression;\n\n    switch (node.type) {\n\n      case 'ArrayExpression':\n        return evaluateArray(node.elements);\n\n      case 'BinaryExpression':\n        return binops[node.operator](evaluateNode(node.left), evaluateNode(node.right));\n\n      case 'CallExpression':\n        let caller, fn, assign;\n        if (node.callee.type === 'MemberExpression') {\n          assign = evaluateMember(node.callee as jsep.MemberExpression);\n          caller = assign[0];\n          fn = assign[1];\n        } else {\n          fn = evaluateNode(node.callee);\n        }\n        if (typeof fn !== 'function') { return undefined; }\n        return fn.apply(caller, evaluateArray(node.arguments));\n\n      case 'ConditionalExpression':\n        return evaluateNode(node.test)\n          ? evaluateNode(node.consequent)\n          : evaluateNode(node.alternate);\n\n      case 'Identifier':\n        return context[node.name];\n\n      case 'Literal':\n        return node.value;\n\n      case 'LogicalExpression':\n        if (node.operator === '||') {\n          return evaluateNode(node.left) || evaluateNode(node.right);\n        } else if (node.operator === '&&') {\n          return evaluateNode(node.left) && evaluateNode(node.right);\n        }\n        return binops[node.operator](evaluateNode(node.left), evaluateNode(node.right));\n\n      case 'MemberExpression':\n        return evaluateMember(node)[1];\n\n      case 'ThisExpression':\n        return context;\n\n      case 'UnaryExpression':\n        return unops[node.operator](evaluateNode(node.argument));\n\n      default:\n        return undefined;\n    }\n  }\n\n  return evaluateNode(_node);\n}\n\nasync function evalAsync(_node: jsep.Expression, context: object, options: EvaluateOptions = {}) {\n\n  async function evaluateArrayAsync(list) {\n    const res = await Promise.all(list.map((v) => evalAsyncNode(v)));\n    return res;\n  }\n\n  async function evaluateMemberAsync(node: jsep.MemberExpression) {\n    const object = await evalAsyncNode(node.object);\n    if (node.computed) {\n      return [object, object[await evalAsyncNode(node.property)]];\n    } else {\n      const name = (node.property as jsep.Identifier).name;\n      return [object, options.implicitOptionalChaining ? object?.[name] : object[name]]\n    }\n  }\n\n  async function evalAsyncNode(jsepNode: jsep.Expression) {\n    const node = jsepNode as AnyExpression;\n\n    // Brackets used for some case blocks here, to avoid edge cases related to variable hoisting.\n    // See: https://stackoverflow.com/questions/57759348/const-and-let-variable-shadowing-in-a-switch-statement\n    switch (node.type) {\n\n      case 'ArrayExpression':\n        return await evaluateArrayAsync(node.elements);\n\n      case 'BinaryExpression': {\n        const [left, right] = await Promise.all([\n          evalAsyncNode(node.left),\n          evalAsyncNode(node.right)\n        ]);\n        return binops[node.operator](left, right);\n      }\n\n      case 'CallExpression': {\n        let caller, fn, assign;\n        if (node.callee.type === 'MemberExpression') {\n          assign = await evaluateMemberAsync(node.callee as jsep.MemberExpression);\n          caller = assign[0];\n          fn = assign[1];\n        } else {\n          fn = await evalAsyncNode(node.callee);\n        }\n        if (typeof fn !== 'function') {\n          return undefined;\n        }\n        return await fn.apply(\n          caller,\n          await evaluateArrayAsync(node.arguments)\n        );\n      }\n\n      case 'ConditionalExpression':\n        return (await evalAsyncNode(node.test))\n          ? await evalAsyncNode(node.consequent)\n          : await evalAsyncNode(node.alternate);\n\n      case 'Identifier':\n        return context[node.name];\n\n      case 'Literal':\n        return node.value;\n\n      case 'LogicalExpression': {\n        if (node.operator === '||') {\n          return (\n            (await evalAsyncNode(node.left)) ||\n            (await evalAsyncNode(node.right))\n          );\n        } else if (node.operator === '&&') {\n          return (\n            (await evalAsyncNode(node.left)) &&\n            (await evalAsyncNode(node.right))\n          );\n        }\n\n        const [left, right] = await Promise.all([\n          evalAsyncNode(node.left),\n          evalAsyncNode(node.right)\n        ]);\n\n        return binops[node.operator](left, right);\n      }\n\n      case 'MemberExpression':\n        return (await evaluateMemberAsync(node))[1];\n\n      case 'ThisExpression':\n        return context;\n\n      case 'UnaryExpression':\n        return unops[node.operator](await evalAsyncNode(node.argument));\n\n      default:\n        return undefined;\n    }\n  }\n\n  return evalAsyncNode(_node);\n}\n\nfunction compile(expression: string | jsep.Expression): (context: object, options: EvaluateOptions) => any {\n  return evaluate.bind(null, jsep(expression));\n}\n\nfunction compileAsync(expression: string | jsep.Expression): (context: object, options: EvaluateOptions) => Promise<any> {\n  return evalAsync.bind(null, jsep(expression));\n}\n\n// Added functions to inject Custom Unary Operators (and override existing ones)\nfunction addUnaryOp(operator: string, _function: unaryCallback): void {\n  jsep.addUnaryOp(operator);\n  unops[operator] = _function;\n}\n\n// Added functions to inject Custom Binary Operators (and override existing ones)\nfunction addBinaryOp(operator: string, precedence_or_fn: number | binaryCallback, _function: binaryCallback): void {\n  if (_function) {\n    jsep.addBinaryOp(operator, precedence_or_fn as number);\n    binops[operator] = _function;\n  } else {\n    jsep.addBinaryOp(operator, DEFAULT_PRECEDENCE[operator] || 1);\n    binops[operator] = precedence_or_fn;\n  }\n}\n\nexport {\n  jsep as parse,\n  evaluate as eval,\n  evalAsync,\n  compile,\n  compileAsync,\n  addUnaryOp,\n  addBinaryOp\n};\n"],"names":["evalAsync","_node","context","options","evalAsyncNode","jsepNode","node","type","evaluateArrayAsync","elements","Promise","all","left","right","binops","operator","caller","fn","assign","_fn","apply","arguments","callee","evaluateMemberAsync","test","consequent","alternate","name","value","unops","argument","undefined","object","computed","property","implicitOptionalChaining","list","map","v","DEFAULT_PRECEDENCE","||","&&","|","^","&","==","!=","===","!==","<",">","<=",">=","<<",">>",">>>","+","-","*","/","%","a","b","~","!","evaluate","evaluateArray","evaluateNode","evaluateMember","_jsepNode","precedence_or_fn","_function","jsep","addBinaryOp","addUnaryOp","expression","bind"],"mappings":"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"}